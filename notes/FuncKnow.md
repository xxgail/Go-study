# 函数

~~本章内容部分来自于《Go语言核心编程》第二章 函数~~
#### 1. 函数概念
1. 首字母大小写决定可见性：大写时其他包可见，小写只有相同的包可以访问。

2. 参数和返回值需要用“()”包裹，如果返回值只有一个且使用的是非命名的参数，可以省略“()”。

3. 函数特点：
    - 可以没有输入值，也可以没有返回值（默认返回0）。
    - 多个相邻的相同类型的参数可以使用简写模式。
    - 支持有名的返回值，可以只写return。
    - **不支持默认值参数**
    - 不支持函数重载
    - 不支持函数嵌套。不支持命名函数的嵌套定义，但支持嵌套匿名函数。

4. 如果多值返回值有错误类型，则一般将错误类型作为最后一个返回值。

5. defer 注册多个延迟调用，先进后出。避免资源泄露。
    - defer 后面必须是函数或者方法的调用。
    - defer 函数的实参在注册时已经传递，defer后的语句不会影响到defer语句中的参数值。
    - defer 必须先注册后执行，不能放在return后面。
    - 主动调用 os.Exit(int) 退出进程时，defer 将不再被执行。
    
#### 2. 闭包
1. 闭包 = 函数 + 引用环境

2. 同一个函数返回的多个闭包共享该函数的局部变量。

3. 对象时附有行为的数据，而闭包是附有数据的行为。

#### 3. panic和recover
1. panic 用来主动抛出错误，recover 用来捕获panic抛出的错误。
    - panic的参数是空接口，所以可以传递任何变量。
    - 发生panic后，程序会从调用panic的函数位置会发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数而退出。
    - defer里面的panic能够被后续执行的defer捕获。
    - recover()和defer一起使用，但是recover只有在defer后面的函数体内被直接调用才能捕获panic终止异常，否则返回nil，异常继续向外传递。
    - 可以有连续多个panic被抛出，连续多个panic的场景只能出现在延迟调用里面。但只有最后一次panic能被捕获。
    - 包中init函数引发的panic只能在init函数中捕获，在main中无法被捕获。函数并不能捕获内部新启动的goroutine所抛出的panic。
    